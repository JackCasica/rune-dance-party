var i=(t=>(t[t.LeftArm=0]="LeftArm",t[t.RightArm=1]="RightArm",t[t.LeftLeg=2]="LeftLeg",t[t.RightLeg=3]="RightLeg",t))(i||{});const f=(t,e)=>Math.floor(Math.random()*(e-t+1)+t),p=t=>{const e=["pink","yellow","orange","purple"],o=[];for(let r=0;r<t;r++){const a=Math.floor(Math.random()*e.length),n=Array(4).fill(0).map(()=>f(1,3));o.push({color:e[a],limbs:n})}return o},c=(t,e)=>t.players[t.players.findIndex(r=>r.playerId===e)],u=t=>{const e=Math.max(...t.map(r=>r.totalScore));return t.filter(r=>r.totalScore===e)},h=["bg-ronchi","bg-willpower-orange","bg-vivid-raspberry","bg-blue-purple"],g=["fixed left-0 top-0 h-[20vw] w-[16vw] ","fixed right-0 top-0 h-[20vw] w-[16vw] ","fixed left-0 bottom-[27%] h-[20vw] w-[16vw] ","fixed right-0 bottom-[27%] h-[20vw] w-[16vw] "],d=p(10);Rune.initLogic({updatesPerSecond:30,minPlayers:4,maxPlayers:4,setup:t=>({gameOver:!1,testActionTriggered:!1,count:0,currentPlayerIndex:0,remainingTime:60,progress:0,currentRound:1,cardStack:d,attractActive:!1,activeCard:d[0],activeCardIndex:0,roundOver:!1,winner:null,timeInSeconds:0,players:t.map((e,o)=>({key:e,playerId:e,playerColor:h[o],attractedCardPosition:g[o],limbs:[1,1,1,1],controlsOrder:["Left Arm","Left Leg","Right Leg","Right Arm"],scoreForRound:0,totalScore:0,correctStreak:0,autoLimb:!1,attract:!1,win:!1}))}),actions:{shuffleEnemyControls:(t,{game:e,playerId:o})=>{e.players.forEach(r=>{if(r.playerId!==o){const a=["Right Arm","Left Leg","Left Arm","Right Leg"];for(let n=2;n>0;n--){const s=Math.floor(Math.random()*(n+1));[a[n],a[s]]=[a[s],a[n]]}r.controlsOrder=a}})},toggleAttract(t,{game:e,playerId:o}){e.players.forEach(a=>{a.attract=!1});const r=c(e,o);r.attract=!0,e.attractActive=!0},toggleAutoLimb:({activeCardIndex:t},{game:e,playerId:o})=>{const r=c(e,o);r.autoLimb=!0,r.limbs[i.LeftArm]=e.cardStack[t].limbs[i.LeftArm]},resetStreak:(t,{game:e,playerId:o})=>{const r=c(e,o);r.correctStreak=0},toggleLimb:({limb:t},{game:e,playerId:o})=>{const r=c(e,o);r.limbs[t]=r.limbs[t]%3+1}},events:{playerJoined:()=>{},playerLeft(){}},update:({game:t})=>{t.progress=Rune.gameTime(),t.remainingTime=6e4-t.progress,t.gameOver=t.remainingTime<=0;const e=Math.floor(t.progress/1e3);t.roundOver=e!==0&&e%6===0&&e!==t.timeInSeconds&&t.progress>0;const o=()=>{t.players.forEach(r=>{r.scoreForRound=r.limbs.reduce((a,n,s)=>{var l;return n===((l=t.cardStack[t.activeCardIndex])==null?void 0:l.limbs[s])?a+1:a},0),r.totalScore=r.totalScore+r.scoreForRound,r.totalScore+r.scoreForRound===r.totalScore+4?r.correctStreak++:r.correctStreak=0,r.autoLimb=!1,r.attract=!1,t.attractActive=!1,r.controlsOrder=["Left Arm","Left Leg","Right Leg","Right Arm"]}),t.currentRound++,t.activeCardIndex++,t.activeCard=t.cardStack[t.activeCardIndex]};t.roundOver&&(console.log("ðŸ”´",t.progress),o()),t.progress===59&&o(),t.gameOver&&(u(t.players).forEach(a=>{a.win=!0}),Rune.gameOver({players:t.players.reduce((a,n)=>({...a,[n.playerId]:n.totalScore}),{}),delayPopUp:!1})),t.timeInSeconds=e}});export{i as L};
